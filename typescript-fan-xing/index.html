
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>TypeScript：泛型</title>
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" type="text/css" href="../assets/built/screen.css?v=9948a6c51d">

    <link rel="shortcut icon" href="../favicon.png" type="image/png">
    <link rel="canonical" href="index.html">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <link rel="amphtml" href="amp/index.html">
    
    <meta property="og:site_name" content="LordMOS">
    <meta property="og:type" content="article">
    <meta property="og:title" content="TypeScript：泛型">
    <meta property="og:description" content="泛型：Generics 软件工程的主要部分就是构建一些即有声明良好且稳定的API又可重用的组件。而这些组件能帮助我们构建一个健壮且可扩展性强的系统。 在高级语言中，我们创造了一种可重用的组件，叫做泛型(Generics)，用来处理不同类型的对象而并非单一类型的对象。 我们先来看一个例子，这个例子描述了一个函数，这个函数的作用是输入什么就输出什么。在不使用泛型的情况下，我们通常会这么声明这个函数。 示例: function identity(arg: any): any {     return arg; } 但是如果我们使用any类型，在我们调用这个方法获得返回值后我们就失去了这个输出结果的数据类型。我们如果输入一个数字(number)，那么能得到的就只有any类型。 因此，我们需要使用类型捕捉的方式来进行类型的获取。这样我们在获取返回值时也可以获取到返回值的类型。在这里，我们使用一种叫做类型变量(type variable)的特殊变量。这种变量专门处理变量的类型而不是变量的值。 示例: function identity&amp;lt;T&amp;gt;(arg: T): T {     return arg; } 现在我们添加了一个类型变量T到函数中，这个变量允许我们获取用户在使用这个函数时所提供的变量类型。这个函数里我们将类型T作为参数类型和返回值类型。">
    <meta property="og:url" content="http://localhost:2368/typescript-fan-xing/">
    <meta property="article:published_time" content="2018-06-04T07:53:07.000Z">
    <meta property="article:modified_time" content="2018-06-04T07:53:07.000Z">
    <meta property="article:tag" content="TypeScript">
    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="TypeScript：泛型">
    <meta name="twitter:description" content="泛型：Generics 软件工程的主要部分就是构建一些即有声明良好且稳定的API又可重用的组件。而这些组件能帮助我们构建一个健壮且可扩展性强的系统。 在高级语言中，我们创造了一种可重用的组件，叫做泛型(Generics)，用来处理不同类型的对象而并非单一类型的对象。 我们先来看一个例子，这个例子描述了一个函数，这个函数的作用是输入什么就输出什么。在不使用泛型的情况下，我们通常会这么声明这个函数。 示例: function identity(arg: any): any {     return arg; } 但是如果我们使用any类型，在我们调用这个方法获得返回值后我们就失去了这个输出结果的数据类型。我们如果输入一个数字(number)，那么能得到的就只有any类型。 因此，我们需要使用类型捕捉的方式来进行类型的获取。这样我们在获取返回值时也可以获取到返回值的类型。在这里，我们使用一种叫做类型变量(type variable)的特殊变量。这种变量专门处理变量的类型而不是变量的值。 示例: function identity&amp;lt;T&amp;gt;(arg: T): T {     return arg; } 现在我们添加了一个类型变量T到函数中，这个变量允许我们获取用户在使用这个函数时所提供的变量类型。这个函数里我们将类型T作为参数类型和返回值类型。">
    <meta name="twitter:url" content="http://localhost:2368/typescript-fan-xing/">
    <meta name="twitter:label1" content="Written by">
    <meta name="twitter:data1" content="Hui Zhong">
    <meta name="twitter:label2" content="Filed under">
    <meta name="twitter:data2" content="TypeScript">
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "LordMOS",
        "logo": "http://localhost:2368/content/images/2018/06/2.jpg"
    },
    "author": {
        "@type": "Person",
        "name": "Hui Zhong",
        "image": {
            "@type": "ImageObject",
            "url": "http://localhost:2368/content/images/2018/06/emo-2.gif",
            "width": 200,
            "height": 200
        },
        "url": "http://localhost:2368/author/hui/",
        "sameAs": []
    },
    "headline": "TypeScript：泛型",
    "url": "http://localhost:2368/typescript-fan-xing/",
    "datePublished": "2018-06-04T07:53:07.000Z",
    "dateModified": "2018-06-04T07:53:07.000Z",
    "keywords": "TypeScript",
    "description": "泛型：Generics 软件工程的主要部分就是构建一些即有声明良好且稳定的API又可重用的组件。而这些组件能帮助我们构建一个健壮且可扩展性强的系统。 在高级语言中，我们创造了一种可重用的组件，叫做泛型(Generics)，用来处理不同类型的对象而并非单一类型的对象。 我们先来看一个例子，这个例子描述了一个函数，这个函数的作用是输入什么就输出什么。在不使用泛型的情况下，我们通常会这么声明这个函数。 示例: function identity(arg: any): any {     return arg; } 但是如果我们使用any类型，在我们调用这个方法获得返回值后我们就失去了这个输出结果的数据类型。我们如果输入一个数字(number)，那么能得到的就只有any类型。 因此，我们需要使用类型捕捉的方式来进行类型的获取。这样我们在获取返回值时也可以获取到返回值的类型。在这里，我们使用一种叫做类型变量(type variable)的特殊变量。这种变量专门处理变量的类型而不是变量的值。 示例: function identity&amp;lt;T&amp;gt;(arg: T): T {     return arg; } 现在我们添加了一个类型变量T到函数中，这个变量允许我们获取用户在使用这个函数时所提供的变量类型。这个函数里我们将类型T作为参数类型和返回值类型。",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "http://localhost:2368/"
    }
}
    </script>

    <script src="../public/ghost-sdk.js?v=9948a6c51d"></script>
<script>
ghost.init({
	clientId: "ghost-frontend",
	clientSecret: "da54f220680d"
});
</script>
    <meta name="generator" content="Ghost 1.23">
    <link rel="alternate" type="application/rss+xml" title="LordMOS" href="../rss/index.html">

</head>
<body class="post-template tag-typescript">

    <div class="site-wrapper">

        

<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
                <a class="site-nav-logo" href="../"><img src="../content/images/2018/06/2.jpg" alt="LordMOS"></a>
            <ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="../">Home</a></li>
    <li class="nav-angular" role="menuitem"><a href="../tag/angular/">Angular</a></li>
    <li class="nav-typescript" role="menuitem"><a href="../tag/typescript/">TypeScript</a></li>
    <li class="nav-ionic" role="menuitem"><a href="../tag/ionic/">ionic</a></li>
    <li class="nav-ecmascript" role="menuitem"><a href="../tag/ecmascript/">ECMAScript</a></li>
    <li class="nav-" role="menuitem"><a href="../tag/other-stuff/">杂记</a></li>
</ul>

    </div>
    <div class="site-nav-right">
        <div class="social-links">
        </div>
            <a class="rss-button" href="https://feedly.com/i/subscription/feed/http://localhost:2368/rss/" target="_blank" rel="noopener"><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24"><circle cx="6.18" cy="17.82" r="2.18"></circle><path d="M4 4.44v2.83c7.03 0 12.73 5.7 12.73 12.73h2.83c0-8.59-6.97-15.56-15.56-15.56zm0 5.66v2.83c3.9 0 7.07 3.17 7.07 7.07h2.83c0-5.47-4.43-9.9-9.9-9.9z"></path></svg>
</a>
    </div>
</nav>
    </div>
</header>


<main id="site-main" class="site-main outer">
    <div class="inner">

        <article class="post-full post tag-typescript no-image">

            <header class="post-full-header">
                <section class="post-full-meta">
                    <time class="post-full-meta-date" datetime="2018-06-04">4 六月 2018</time>
                        <span class="date-divider">/</span> <a href="../tag/typescript/">TypeScript</a>
                </section>
                <h1 class="post-full-title">TypeScript：泛型</h1>
            </header>


            <section class="post-full-content">
                <div class="kg-card-markdown"><h2 id="generics">泛型：<code>Generics</code></h2>
<p>软件工程的主要部分就是构建一些即有声明良好且稳定的API又可重用的组件。而这些组件能帮助我们构建一个健壮且可扩展性强的系统。</p>
<p>在高级语言中，我们创造了一种可重用的组件，叫做泛型(<code>Generics</code>)，用来处理不同类型的对象而并非单一类型的对象。</p>
<p>我们先来看一个例子，这个例子描述了一个函数，这个函数的作用是输入什么就输出什么。在不使用泛型的情况下，我们通常会这么声明这个函数。</p>
<p><strong>示例:</strong></p>
<pre><code>function identity(arg: any): any {
    return arg;
}
</code></pre>
<p>但是如果我们使用<code>any</code>类型，在我们调用这个方法获得返回值后我们就失去了这个输出结果的数据类型。我们如果输入一个数字(<code>number</code>)，那么能得到的就只有<code>any</code>类型。</p>
<p>因此，我们需要使用类型捕捉的方式来进行类型的获取。这样我们在获取返回值时也可以获取到返回值的类型。在这里，我们使用一种叫做<em>类型变量</em>(<code>type variable</code>)的特殊变量。这种变量专门处理变量的类型而不是变量的值。</p>
<p><strong>示例:</strong></p>
<pre><code>function identity&lt;T&gt;(arg: T): T {
    return arg;
}
</code></pre>
<p>现在我们添加了一个类型变量<code>T</code>到函数中，这个变量允许我们获取用户在使用这个函数时所提供的变量类型。这个函数里我们将类型<code>T</code>作为参数类型和返回值类型。我们可以在一个函数里使用某一种类型作为参数类型，而返回值类型则是另外一种。此时，我们就可以称上面那个函数为泛型的。</p>
<p>我们现在用两种方式来调用这个函数。第一种就是我们将参数的类型和参数本身传给这个函数。需要注意的是类型参数需要用<code>&lt;&gt;</code>包裹。如：</p>
<p><strong>示例:</strong></p>
<pre><code>let output = identity&lt;string&gt;("myString");  // type of output will be 'string'
</code></pre>
<p>同样，我们可以通过只传递参数来隐式调用函数，编译器会通过<em>类型参数推理</em>(<code>type argument inference</code>)的方式告知编译器我们使用了哪种类型作为类型<code>T</code>。</p>
<p><strong>示例:</strong></p>
<pre><code>let output = identity("myString");  // type of output will be 'string'
</code></pre>
<p>这种方式看起来更易读易写，但是在因对复杂的情况时，请不要省略类型变量，以防止造成不必要的错误。</p>
<hr>
<h2 id="workingwithgenerictypevariables">使用泛型类型变量:<code>Working with Generic Type Variables</code></h2>
<p>在你使用泛型时，编译器会强制要求你的函数体内每一个使用了泛型类型的变量的属性是准确的。</p>
<p>我们先来看一下例子。</p>
<p><strong>示例:</strong></p>
<pre><code>function loggingIdentity&lt;T&gt;(arg: T): T {
    console.log(arg.length);  // Error: T doesn't have .length
    return arg;
}
</code></pre>
<p>这个地方会报错，原因是<code>T</code>类型的数据并不一定包含<code>length</code>这个属性。再来看下一个例子。</p>
<p><strong>示例:</strong></p>
<pre><code>function loggingIdentity&lt;T&gt;[](arg: T[]): T[] {
    console.log(arg.length);  // Array has a .length, so no more error
    return arg;
}
</code></pre>
<p>此处没有错误，原因是一个数组是有长度的。如果我们希望传入的是一个<code>T</code>类型的数据且它有<code>length</code>属性，我们应该怎么做呢？下面我们来介绍泛型类型。</p>
<hr>
<h2 id="generictype">泛型类型:<code>Generic Type</code></h2>
<p>我们来看一下完整的泛型函数定义。</p>
<p><strong>示例:</strong></p>
<pre><code>function identity&lt;T&gt;(arg: T): T {
    return arg;
}
let myIdentity: &lt;T&gt;(arg: T) =&gt; T = identity;
</code></pre>
<p>我们可以在函数定义时修改函数中类型参数的参数名。</p>
<p><strong>示例:</strong></p>
<pre><code>function identity&lt;T&gt;(arg: T): T {
    return arg;
}
let myIdentity: &lt;U&gt;(arg: U) =&gt; U = identity;
</code></pre>
<p>同样，我们可以通过类似写对象的方式来写泛型的调用签名。（关于调用签名，我们可以回顾接口章节）。</p>
<p><strong>示例:</strong></p>
<pre><code>function identity&lt;T&gt;(arg: T): T {
    return arg;
}
let myIdentity: {&lt;T&gt;(arg: T): T} = identity;
</code></pre>
<p>此外，我们还可以定义一个描述泛型函数类型的接口。</p>
<p><strong>示例:</strong></p>
<pre><code>interface GenericIdentityFn {
    &lt;T&gt;(arg: T): T;
}
function identity&lt;T&gt;(arg: T): T {
    return arg;
}
let myIdentity: GenericIdentityFn = identity;
</code></pre>
<p>更进一步，我们可以通过将泛型类型变量提取到接口描述中，使接口中所有的函数、属性都接受泛型类型的描述，使其成为一个泛型接口。</p>
<p><strong>示例:</strong></p>
<pre><code>interface GenericIdentityFn&lt;T&gt; {
    (arg: T): T;
}
function identity&lt;T&gt;(arg: T): T {
    return arg;
}
let myIdentity: GenericIdentityFn&lt;number&gt; = identity;
</code></pre>
<p>在此时，我们使用接口来描述一个变量时，就要告知这个接口接收什么样的类型来描述泛型。</p>
<p>和描述一个泛型接口类似的，我们来描述一个泛型类。</p>
<p><strong>示例:</strong></p>
<pre><code>class GenericNumber&lt;T&gt; {
    zeroValue: T;
    add: (x: T, y: T) =&gt; T;
}
let myGenericNumber = new GenericNumber&lt;number&gt;();
myGenericNumber.zeroValue = 0;
myGenericNumber.add = function(x, y) { return x + y; };
</code></pre>
<p>我们在讨论类的时候说到类其实有两个部分，一个是静态部分一个是实例部分。而泛型只覆盖了实例部分。而在使用类的静态部分时，我们无法使用泛型来描述它的静态部分。</p>
<hr>
<h2 id="genericconstraints">泛型约束：<code>Generic Constraints</code></h2>
<p>我们现在来讨论一下泛型的兼容性。回到之前的一个例子。</p>
<p><strong>示例:</strong></p>
<pre><code>function loggingIdentity&lt;T&gt;(arg: T): T {
    console.log(arg.length);  // Error: T doesn't have .length
    return arg;
}
</code></pre>
<p>在这个例子中，我们需要访问<code>arg</code>的<code>length</code>属性，而编译器不能确保所有的类型全都有这个属性，所以它会报错。而通常我们在使用这个函数时，我们期望的并不是所有的类型，而是带有<code>length</code>属性的类型。所以如果一个变量有一些成员，且某些成员是必须的，我们就需要列出需求清单来约束传入的类型。</p>
<p>为了解决这个问题，我们通过声明一个接口来描述我们的约束。在这里，我们创建一个带有<code>length</code>属性的接口，并使类型<code>T</code>扩展它来作为约束。</p>
<p><strong>示例:</strong></p>
<pre><code>interface Lengthwise {
    length: number;
}
function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T {
    console.log(arg.length);  // Now we know it has a .length property, so no more error
    return arg;
}
loggingIdentity(3);  // Error, number doesn't have a .length property
loggingIdentity({length: 10, value: 3});
</code></pre>
<p>这样就意味着在做类型检查时，我们会对参数进行检查，看看这个类型是否符合接口的描述——即传入的对象必须有一个实例部分的属性，名字叫做<code>length</code>且类型是<code>number</code>。如果调用的参数不符合这个约束，则编译器会报错。</p>
<p>同样我们可以使用泛型来扩展泛型。</p>
<p><strong>示例:</strong></p>
<pre><code>function copyFields&lt;T extends U, U&gt;(target: T, source: U): T {
    for (let id in source) {
        target[id] = source[id];
    }
    return target;
}

let x = { a: 1, b: 2, c: 3, d: 4 };
copyFields(x, { b: 10, d: 20 }); // okay
copyFields(x, { Q: 90 });  // error: property 'Q' isn't declared in 'x'.
</code></pre>
<p>这个描述表示的是，我们接受两个泛型类型的参数用作函数的参数，而第一个类型要被第二个类型所约束，即第二个类型的对象属性必须存在于第一个类型的对象属性列表中。否则就会报错。我们可以将第一个类型看成是子类而第二个类型看成是父类，但是要求并不如继承那样严格罢了。</p>
<hr>
<h2 id="usingclasstypesingenerics">在泛型中使用类类型：<code>Using Class Types in Generics</code></h2>
<p>我们可以讲一个类作为类型传入到泛型声明的函数中。所以我们需要对其做一个约束：我们判断传入的类型是否存在一个<code>new</code>的函数，且这个函数返回一个该类型的对象。</p>
<p><strong>示例:</strong></p>
<pre><code>function create&lt;T&gt;(c: {new(): T; }): T {
    return new c();
}
</code></pre>
<p>这个代码分为几个部分。接受的参数为<code>c: {new(): T; }</code>，表示传入的参数名为<code>c</code>，它有一个名为<code>new()</code>的属性(这个属性恰好就是构造函数)，且这个属性的返回值为<code>T</code>，这就决定了传入的<code>c</code>是类类型，即类的类型而不是对象，作为一个参数传入函数中。如果要理解这个模型我们可以借助接口章节的范例来理解。其次，我们定义了返回类型为<code>T</code>的返回值，而在函数体内，我们通过<code>new</code>来新建类型<code>c</code>的对象。</p>
<p>这和接口章节的范例有些类似。此处我们通过泛型这种方式创建的是任意一种类型的对象*(此处可以考证一下如果我们对<code>new()</code>的参数列表进行约束是否会影响传入的类)*。而使用接口描述一个符合构造函数约束的类，然后用接口作为类型检查的标准来检查这个传入的类是否实现了该接口。区别就在于这个类是否是一个接口的实现。</p>
<p><strong>示例:</strong></p>
<pre><code>class BeeKeeper {
    hasMask: boolean;
}
class ZooKeeper {
    nametag: string;
}
class Animal {
    numLegs: number;
}
class Bee extends Animal {
    keeper: BeeKeeper;
}
class Lion extends Animal {
    keeper: ZooKeeper;
}
function findKeeper&lt;A extends Animal, K&gt; (a: {new(): A; prototype: {keeper: K}}): K {
    return a.prototype.keeper;
}
findKeeper(Lion).nametag;  // typechecks!
</code></pre>
<p>(此处需要理解<em>new</em>操作符和<em>prototype</em>)</p>
</div>
            </section>


            <footer class="post-full-footer">


                    
<section class="author-card">
        <img class="author-profile-image" src="../content/images/2018/06/emo-2.gif" alt="Hui Zhong">
    <section class="author-card-content">
        <h4 class="author-card-name"><a href="../author/hui/">Hui Zhong</a></h4>
            <p>Read <a href="../author/hui/">more posts</a> by this author.</p>
    </section>
</section>
<div class="post-full-footer-right">
    <a class="author-card-button" href="../author/hui/">Read More</a>
</div>


            </footer>


        </article>

    </div>
</main>

<aside class="read-next outer">
    <div class="inner">
        <div class="read-next-feed">
                <article class="read-next-card" style="background-image: url(https://casper.ghost.org/v1.0.0/images/blog-cover.jpg)">
                    <header class="read-next-card-header">
                        <small class="read-next-card-header-sitetitle">— LordMOS —</small>
                        <h3 class="read-next-card-header-title"><a href="../tag/typescript/">TypeScript</a></h3>
                    </header>
                    <div class="read-next-divider"><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24"><path d="M13 14.5s2 3 5 3 5.5-2.463 5.5-5.5S21 6.5 18 6.5c-5 0-7 11-12 11C2.962 17.5.5 15.037.5 12S3 6.5 6 6.5s4.5 3.5 4.5 3.5"></path></svg>
</div>
                    <div class="read-next-card-content">
                        <ul>
                            <li><a href="../typescript-cong-ling-kai-shi-de-qian-duan-mian-xiang-dui-xiang-rpg/">TypeScript：从零开始的前端面向对象RPG</a></li>
                        </ul>
                    </div>
                    <footer class="read-next-card-footer">
                        <a href="../tag/typescript/">1 post →</a>
                    </footer>
                </article>

                <article class="post-card post tag-ecmascript no-image">
    <div class="post-card-content">
        <a class="post-card-content-link" href="../han-shu-shi-bian-cheng-ji-chu-han-shu-thisyu-bi-bao/">
            <header class="post-card-header">
                    <span class="post-card-tags">ECMAScript</span>
                <h2 class="post-card-title">函数式编程基础：函数、this与闭包</h2>
            </header>
            <section class="post-card-excerpt">
                <p>什么是函数？ 函数的本质是数据的映射。函数接受一个输入，并输出映射结果。 函数的返回值 函数必然会有一个返回值，不论你是function表达式还是lambda表达式。如果没有显示写return语句，则默认返回值为undefined。 function表达式中的this指针 在function表达式中，this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象。 举例： let a = function() {     console.log(this) } a(); // Window { ... } let b = {     str: 'Hi',     fun: function() {         console.log(this)     } } b.</p>
            </section>
        </a>
        <footer class="post-card-meta">

            <ul class="author-list">
                <li class="author-list-item">

                    <div class="author-name-tooltip">
                        Hui Zhong
                    </div>

                        <a href="../author/hui/" class="static-avatar"><img class="author-profile-image" src="../content/images/2018/06/emo-2.gif" alt="Hui Zhong"></a>
                </li>
            </ul>

            <span class="reading-time">4 min read</span>

        </footer>
    </div>
</article>

                <article class="post-card post tag-ionic no-image">
    <div class="post-card-content">
        <a class="post-card-content-link" href="../shi-yong-angularhe-ionicgou-jian-hybrid-app-er-zhun-bei-pian/">
            <header class="post-card-header">
                    <span class="post-card-tags">ionic</span>
                <h2 class="post-card-title">使用Angular和ionic构建Hybrid App（二）—— 准备篇</h2>
            </header>
            <section class="post-card-excerpt">
                <p>俗话说“工欲善其事，必先利其器”。作为一个需要开发App的Web开发者来说，直接动手之前，必然需要做一些准备性的调研。这里，我就列举几个大家比较关心并且很大概率会去调研的问题。 如何解决用户体验的问题 都说Native App如丝般顺滑，Web App的表现就难说了。这句话其实不无道理，在Android 5.0之前，Android手机自带的WebView（应用内嵌浏览器）性能真的堪忧，况且各大厂商还喜欢魔改浏览器，导致兼容性、性能都存在很大问题。 在Android 5.0之后，Android系统自带的WebView就被替换成了Chromium，性能提升的非常明显，而iOS设备上的WebView一直性能都很出色，所以现在的最大问题就是Android 5.0以下的设备如何提升性能的问题。 这个时候（</p>
            </section>
        </a>
        <footer class="post-card-meta">

            <ul class="author-list">
                <li class="author-list-item">

                    <div class="author-name-tooltip">
                        Hui Zhong
                    </div>

                        <a href="../author/hui/" class="static-avatar"><img class="author-profile-image" src="../content/images/2018/06/emo-2.gif" alt="Hui Zhong"></a>
                </li>
            </ul>

            <span class="reading-time">5 min read</span>

        </footer>
    </div>
</article>

        </div>
    </div>
</aside>

<div class="floating-header">
    <div class="floating-header-logo">
        <a href="../">
                <img src="../content/images/2018/06/10.png" alt="LordMOS icon">
            <span>LordMOS</span>
        </a>
    </div>
    <span class="floating-header-divider">—</span>
    <div class="floating-header-title">TypeScript：泛型</div>
    <div class="floating-header-share">
        <div class="floating-header-share-label">Share this <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24">
    <path d="M7.5 15.5V4a1.5 1.5 0 1 1 3 0v4.5h2a1 1 0 0 1 1 1h2a1 1 0 0 1 1 1H18a1.5 1.5 0 0 1 1.5 1.5v3.099c0 .929-.13 1.854-.385 2.748L17.5 23.5h-9c-1.5-2-5.417-8.673-5.417-8.673a1.2 1.2 0 0 1 1.76-1.605L7.5 15.5zm6-6v2m-3-3.5v3.5m6-1v2"></path>
</svg>
</div>
        <a class="floating-header-share-tw" href="https://twitter.com/share?text=TypeScript%EF%BC%9A%E6%B3%9B%E5%9E%8B&amp;url=http://localhost:2368/typescript-fan-xing/" onclick="window.open(this.href, 'share-twitter', 'width=550,height=235');return false;">
            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 32 32"><path d="M30.063 7.313c-.813 1.125-1.75 2.125-2.875 2.938v.75c0 1.563-.188 3.125-.688 4.625a15.088 15.088 0 0 1-2.063 4.438c-.875 1.438-2 2.688-3.25 3.813a15.015 15.015 0 0 1-4.625 2.563c-1.813.688-3.75 1-5.75 1-3.25 0-6.188-.875-8.875-2.625.438.063.875.125 1.375.125 2.688 0 5.063-.875 7.188-2.5-1.25 0-2.375-.375-3.375-1.125s-1.688-1.688-2.063-2.875c.438.063.813.125 1.125.125.5 0 1-.063 1.5-.25-1.313-.25-2.438-.938-3.313-1.938a5.673 5.673 0 0 1-1.313-3.688v-.063c.813.438 1.688.688 2.625.688a5.228 5.228 0 0 1-1.875-2c-.5-.875-.688-1.813-.688-2.75 0-1.063.25-2.063.75-2.938 1.438 1.75 3.188 3.188 5.25 4.25s4.313 1.688 6.688 1.813a5.579 5.579 0 0 1 1.5-5.438c1.125-1.125 2.5-1.688 4.125-1.688s3.063.625 4.188 1.813a11.48 11.48 0 0 0 3.688-1.375c-.438 1.375-1.313 2.438-2.563 3.188 1.125-.125 2.188-.438 3.313-.875z"></path></svg>
        </a>
        <a class="floating-header-share-fb" href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:2368/typescript-fan-xing/" onclick="window.open(this.href, 'share-facebook','width=580,height=296');return false;">
            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 32 32"><path d="M19 6h5V0h-5c-3.86 0-7 3.14-7 7v3H8v6h4v16h6V16h5l1-6h-6V7c0-.542.458-1 1-1z"></path></svg>
        </a>
    </div>
    <progress class="progress" value="0">
        <div class="progress-container">
            <span class="progress-bar"></span>
        </div>
    </progress>
</div>




        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="../">LordMOS</a> © 2018</section>
                <nav class="site-footer-nav">
                    <a href="../">Latest Posts</a>
                    
                    
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>


    <script src="https://code.jquery.com/jquery-3.2.1.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="../assets/js/jquery.fitvids.js?v=9948a6c51d"></script>


    <script>

// NOTE: Scroll performance is poor in Safari
// - this appears to be due to the events firing much more slowly in Safari.
//   Dropping the scroll event and using only a raf loop results in smoother
//   scrolling but continuous processing even when not scrolling
$(document).ready(function () {
    // Start fitVids
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
    // End fitVids

    var progressBar = document.querySelector('progress');
    var header = document.querySelector('.floating-header');
    var title = document.querySelector('.post-full-title');

    var lastScrollY = window.scrollY;
    var lastWindowHeight = window.innerHeight;
    var lastDocumentHeight = $(document).height();
    var ticking = false;

    function onScroll() {
        lastScrollY = window.scrollY;
        requestTick();
    }

    function onResize() {
        lastWindowHeight = window.innerHeight;
        lastDocumentHeight = $(document).height();
        requestTick();
    }

    function requestTick() {
        if (!ticking) {
            requestAnimationFrame(update);
        }
        ticking = true;
    }

    function update() {
        var trigger = title.getBoundingClientRect().top + window.scrollY;
        var triggerOffset = title.offsetHeight + 35;
        var progressMax = lastDocumentHeight - lastWindowHeight;

        // show/hide floating header
        if (lastScrollY >= trigger + triggerOffset) {
            header.classList.add('floating-active');
        } else {
            header.classList.remove('floating-active');
        }

        progressBar.setAttribute('max', progressMax);
        progressBar.setAttribute('value', lastScrollY);

        ticking = false;
    }

    window.addEventListener('scroll', onScroll, {passive: true});
    window.addEventListener('resize', onResize, false);

    update();

});
</script>


    

</body>
